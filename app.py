# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nDQjbVI8-tTIyYOI1qB8X1HGNh9Q4zfa

Link repositório: https://github.com/pedroreis01/analiseEstatistica

Para realizar cada tarefa, é necessário executar os módulos de **Importações** e **Processamento de Excel**.

# **Importações**
"""

# Passo 1: Importar bibliotecas necessárias
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from IPython.display import display, HTML
import seaborn as sns

"""# **Processamento Excel**"""

# Passo 2: Carregar dados do Excel
# Você pode usar o seguinte comando para carregar um arquivo do seu Google Drive:
# from google.colab import files
# uploaded = files.upload()  # Isso abrirá uma caixa para você escolher o arquivo Excel
link_excel = 'https://docs.google.com/spreadsheets/d/1wmpM9yLh5ZX7HSnUG3TTDiJsZxhqRzac/export'
# Supondo que o nome do arquivo seja 'data.xlsx', ajuste conforme necessário
df = pd.read_excel(link_excel)

"""# **Tarefa 1**"""

# Passo 3: Calcular Tabelas de Frequência

def calcular_frequencias_salario(df):
    """Calcula a tabela de frequências para a variável salário com intervalos arredondados e 3 casas decimais"""

    # Remover valores negativos
    df['salary'] = df['salary'].abs()

    # Criar DataFrame
    df = pd.DataFrame(df['salary'], columns=['salary'])

    # Definir o número de intervalos usando a regra de Sturges
    n = len(df)  # Número total de observações
    num_intervals = int(1 + 3.322 * np.log10(n))  # Regra de Sturges

    # Gerar intervalos automaticamente, garantindo que o mínimo seja zero
    min_salary = df['salary'].min()
    max_salary = df['salary'].max()

    # Criar os bins para os intervalos
    bins = pd.interval_range(start=min_salary, end=max_salary, periods=num_intervals)

    # Atribuir intervalos aos salários
    df['interval'] = pd.cut(df['salary'], bins=bins, include_lowest=True)

    # Calcular frequência dos intervalos
    salary_freq = df['interval'].value_counts().sort_index()

    # Frequência absoluta (fi)
    fi = salary_freq.values

    # Frequência percentual (fi%)
    fi_percent = np.round((fi / n) * 100, 3)

    # Frequência acumulada (Fi)
    Fi = np.cumsum(fi)

    # Frequência acumulada percentual (Fi%)
    Fi_percent = np.round(np.cumsum(fi_percent), 3)

    # Ponto médio (Xi)
    Xi = salary_freq.index.map(lambda x: np.round((x.left + x.right) / 2, 3))

    # Formatar os intervalos para não ter casas decimais
    formatted_intervals = salary_freq.index.map(lambda x: f"({int(x.left)}, {int(x.right)}]")

    # Gerar DataFrame de frequência com intervalos formatados e valores arredondados
    salary_freq_df = pd.DataFrame({
        'Faixa de Salário (USD)': formatted_intervals,
        'Ponto Médio (Xi)': Xi,
        'Frequência (fi)': fi,
        'Frequência % (fi%)': fi_percent,
        'Frequência Acumulada (Fi)': Fi,
        'Frequência Acumulada % (Fi%)': Fi_percent
    })

    # Gerar dicionário para uso no template HTML
    salary_freq_dict = salary_freq_df.set_index('Faixa de Salário (USD)').to_dict()

    return salary_freq_df, salary_freq_dict

# Calcular a tabela de frequência de salários
salario_freq_df, salario_freq_dict = calcular_frequencias_salario(df)
display(HTML(salario_freq_df.to_html(index=False, border=0)))

"""# **Tarefa 2**"""

def calcular_frequencias_job_title(df):
    """Calcula a tabela de frequências para a variável job_title."""

    # Calcular a frequência de títulos de trabalho
    job_title_freq = df['job_title'].value_counts().reset_index()
    job_title_freq.columns = ['Título do Trabalho', 'Frequência']

    # Total de observações
    total = job_title_freq['Frequência'].sum()

    # Frequência percentual (fi%)
    job_title_freq['Frequência % (fi%)'] = np.round((job_title_freq['Frequência'] / total) * 100, 3)

    # Frequência acumulada (Fi)
    job_title_freq['Frequência Acumulada (Fi)'] = job_title_freq['Frequência'].cumsum()

    # Frequência acumulada percentual (Fi%)
    job_title_freq['Frequência Acumulada % (Fi%)'] = np.round(job_title_freq['Frequência % (fi%)'].cumsum(), 3)

    # Ponto médio (Xi) - usaremos o índice ordinal como ponto médio
    job_title_freq['Ponto Médio (Xi)'] = np.round(range(1, len(job_title_freq) + 1), 3)

    # Reorganizar as colunas para que o ponto médio fique logo após o título do trabalho
    job_title_freq = job_title_freq[['Título do Trabalho', 'Ponto Médio (Xi)', 'Frequência', 'Frequência % (fi%)', 'Frequência Acumulada (Fi)', 'Frequência Acumulada % (Fi%)']]

    return job_title_freq

# Calcular a tabela de frequência por título de trabalho
job_title_freq = calcular_frequencias_job_title(df)
display(HTML(job_title_freq.to_html(index=False, border=0)))

"""# **Tarefa 3**

## Gráfico nível de experiência
"""

def plot_experience_level(df):
    """Plota a frequência por nível de experiência como um gráfico de barras horizontal com valores nas barras."""
    # Calcular a frequência de cada nível de experiência
    experience_freq = df['experience_level'].value_counts()

    # Criar o gráfico de barras horizontais
    plt.figure(figsize=(12, 6))
    bars = experience_freq.plot(kind='barh', color='blue')

    # Exibir o valor exato ao lado de cada barra
    for bar in bars.patches:
        width = bar.get_width()
        plt.text(width, bar.get_y() + bar.get_height() / 2, f'{int(width)}',
                 ha='left', va='center', fontsize=10)

    plt.title('Distribuição por Nível de Experiência')
    plt.xlabel('Frequência')
    plt.ylabel('Nível de Experiência')

    # Remover as linhas verticais da grade
    plt.grid(False)

    plt.show()
plot_experience_level(df)

"""## Gráfico tipo de trabalho"""

def plot_employment_type(df):
    """Plota a frequência por tipo de trabalho usando gráfico de barras com escala logarítmica."""
    employment_freq = df['employment_type'].value_counts()

    plt.figure(figsize=(8, 5))
    bars = employment_freq.plot(kind='bar', color='skyblue')

    # Usando escala logarítmica para o eixo y
    plt.yscale('log')

    # Exibir o valor exato no topo de cada barra
    for bar in bars.patches:
        height = bar.get_height()
        plt.text(bar.get_x() + bar.get_width() / 2, height, f'{int(height)}',
                 ha='center', va='bottom', fontsize=10)

    plt.title('Frequência por Tipo de Trabalho (Escala Logarítmica)')
    plt.xlabel('Tipo de Trabalho')
    plt.ylabel('Frequência (Escala Logarítmica)')
    plt.xticks(rotation=45)

    # Remover as linhas horizontais
    plt.grid(False)

    plt.show()

# Exemplo de uso
# plot_employment_type(df)

# Exemplo de uso
plot_employment_type(df)

"""## Gráfico salário em USD


"""

def plot_salary(df):
    """Plota a distribuição do salário em USD como um histograma."""
    plt.figure(figsize=(8, 5))
    # Plotar histograma com ajuste automático de bins
    plt.hist(df['salary_in_usd'], bins='auto', color='lightgreen', edgecolor='black')
    plt.title('Distribuição do Salário em USD')
    plt.xlabel('Salário (USD)')
    plt.ylabel('Frequência')
    plt.grid(axis='y')
    plt.xticks(rotation=45)  # Rotacionar os rótulos do eixo x, se necessário
    plt.show()
plot_salary(df)

"""## Gráfico porcentagem de trabalho remoto"""

def plot_remote_ratio(df):
    """Plota a frequência por porcentagem de trabalho remoto com valores nas barras."""
    remote_freq = df['remote_ratio'].value_counts()

    # Criar o gráfico de barras
    plt.figure(figsize=(8, 5))
    bars = remote_freq.plot(kind='bar', color='salmon')

    # Exibir o valor exato no topo de cada barra
    for bar in bars.patches:
        height = bar.get_height()
        plt.text(bar.get_x() + bar.get_width() / 2, height, f'{int(height)}',
                 ha='center', va='bottom', fontsize=10)

    plt.title('Frequência por Porcentagem de Trabalho Remoto')
    plt.xlabel('Porcentagem de Trabalho Remoto')
    plt.ylabel('Frequência')
    plt.xticks(rotation=45)

    # Remover as linhas horizontais
    plt.grid(False)

    plt.show()
plot_remote_ratio(df)

"""## Gráfico tamanho da empresa"""

def plot_company_size(df):
    """Plota a frequência por tamanho da empresa com valores nas barras."""
    company_size_freq = df['company_size'].value_counts()

    # Criar o gráfico de barras
    plt.figure(figsize=(8, 5))
    bars = company_size_freq.plot(kind='bar', color='lightcoral')

    # Exibir o valor exato no topo de cada barra
    for bar in bars.patches:
        height = bar.get_height()
        plt.text(bar.get_x() + bar.get_width() / 2, height, f'{int(height)}',
                 ha='center', va='bottom', fontsize=10)

    plt.title('Frequência por Tamanho da Empresa')
    plt.xlabel('Tamanho da Empresa')
    plt.ylabel('Frequência')
    plt.xticks(rotation=45)

    # Remover as linhas horizontais
    plt.grid(False)

    plt.show()
plot_company_size(df)

"""# **Tarefa 4**

**Análise:**
A análise das medidas descritivas revela uma distribuição de salários bastante ampla. A média salarial de 149.686,78 é superior à mediana de 141.300,00, o que sugere a presença de valores altos que puxam a média para cima. O intervalo entre o mínimo de 15.000,00 e o máximo de 800.000,00 indica uma grande dispersão nos dados.

O desvio padrão de 68,505.29 reforça essa variabilidade, indicando uma dispersão significativa em torno da média. O coeficiente de variação de 45.77% também demonstra alta variabilidade nos salários, sugerindo que os valores estão dispersos de forma heterogênea.

A diferença entre o 1º quartil (Q1) de 101.125,00 e o 3º quartil (Q3) de 185.900,00 mostra que 50% dos salários estão dentro dessa faixa, mas a amplitude e o desvio padrão indicam a presença de valores discrepantes nos extremos, o que deve ser levado em consideração ao interpretar os dados.

Essas informações refletem uma distribuição com salários bastante variados, com uma leve assimetria e forte presença de outliers no topo.

## **Medidas Descritivas Salário USD**
"""

from ctypes import alignment
def calcular_medidas_desc_salario(df):
    """Calcula e plota as medidas descritivas para a variável salary_in_usd"""

    # Calculando as medidas descritivas
    media = df['salary_in_usd'].mean()
    mediana = df['salary_in_usd'].median()
    minimo = df['salary_in_usd'].min()
    maximo = df['salary_in_usd'].max()
    desvio_padrao = df['salary_in_usd'].std()
    coeficiente_variacao = desvio_padrao / media * 100
    primeiro_quartil = df['salary_in_usd'].quantile(0.25)
    terceiro_quartil = df['salary_in_usd'].quantile(0.75)

    # Criando um dicionário das medidas descritivas
    medidas_descritivas = {
        'Média': media,
        'Mediana': mediana,
        'Mínimo': minimo,
        'Máximo': maximo,
        'Desvio Padrão': desvio_padrao,
        'Coeficiente de Variação (%)': coeficiente_variacao,
        '1º Quartil (Q1)': primeiro_quartil,
        '3º Quartil (Q3)': terceiro_quartil
    }


    # Criar DataFrame a partir do dicionário de medidas descritivas
    df_medidas = pd.DataFrame(medidas_descritivas.items(), columns=['Medida', 'Valor'])
    df_medidas['Valor'] = df_medidas['Valor'].round(2)

    # Exibir as medidas descritivas
    display(HTML(df_medidas.to_html(index=False, border=0)))

calcular_medidas_desc_salario(df)

"""## **Boxplot Salário USD**"""

from ctypes import alignment
def gerar_bloxpot_salario(df):
    # Criando o boxplot para a variável salary_in_usd
    plt.figure(figsize=(8, 5))
    sns.boxplot(x=df['salary_in_usd'], color='lightblue')
    plt.title('Boxplot de Salary in USD')
    plt.xlabel('Salário USD')
    plt.grid(True)
    plt.show()
gerar_bloxpot_salario(df)

"""# **Tarefa 5**

**Análise:** Os dados da tabela de contingência e o gráfico de calor revelam alguns padrões interessantes. Primeiramente, observa-se que a frequência absoluta de profissionais seniores (Senior) trabalhando 0% remoto é a mais alta (5.290), seguidos de Mid-level (1.910). Além disso, a proporção de trabalho remoto de 100% para os níveis Senior (2.241) e Mid-level (1.061) também é significativa, indicando que esses níveis de experiência têm uma tendência forte tanto para trabalho totalmente presencial quanto para totalmente remoto.

Os níveis Entry-level e Executive-level apresentam frequências absolutas e percentuais menores em todas as categorias de trabalho remoto, sugerindo que esses níveis têm menos flexibilidade ou oportunidade para o trabalho remoto. A categoria de 50% de trabalho remoto tem as menores frequências em todos os níveis de experiência, sugerindo que o trabalho híbrido é menos comum em comparação com as outras categorias.

No geral, a análise indica uma clara preferência por trabalho totalmente presencial ou totalmente remoto para níveis de experiência mais altos, enquanto níveis de experiência mais baixos têm menos oportunidades de trabalho remoto. Esses padrões podem ajudar a empresa a entender melhor a distribuição e preferências de trabalho remoto entre diferentes níveis de experiência.

## **Tabela de Contingência de Frequência**
"""

def tabela_contingencia_freq(df):
    """Cria e exibe a tabela de contingência com frequências absolutas."""
    contingencia = pd.crosstab(df['experience_level'], df['remote_ratio'])
    display(HTML(contingencia.to_html(index=False, border=0)))

tabela_contingencia_freq(df)

"""## **Tabela de Contingência de Percentuais**"""

def tabela_contingencia_perc(df):
    """Cria e exibe a tabela de contingência com percentuais do total geral."""
    percentual_total = pd.crosstab(df['experience_level'], df['remote_ratio'], normalize='all') * 100
    display(HTML(percentual_total.round(2).to_html(index=False, border=0)))

tabela_contingencia_perc(df)

"""## **Gráfico de Calor (Heatmap)**"""

def plot_heatmap(df):
    """Plota o gráfico de calor (heatmap) baseado na tabela de contingência de frequências absolutas."""
    contingencia = pd.crosstab(df['experience_level'], df['remote_ratio'])
    plt.figure(figsize=(10, 6))
    sns.heatmap(contingencia, annot=True, cmap='Blues', fmt="d", cbar_kws={'label': 'Frequência'})
    plt.title('Tabela de Contingência - Frequência entre experience_level e remote_ratio')
    plt.ylabel('Experience Level')
    plt.xlabel('Remote Ratio')
    plt.show()

plot_heatmap(df)

"""# **Tarefa 6**

## **Tabela de Contingência de Frequência**
"""

def generate_frequency_table(df):
    """Gera e exibe a tabela de contingência com frequências absolutas."""
    contingency = pd.crosstab(df['employment_type'], df['company_size'])
    display(HTML(contingency.to_html(index=False, border=0)))

generate_frequency_table(df)

"""## **Tabela de Contingência de Percentuais**"""

def generate_percentage_table(df):
    """Gera e exibe a tabela de contingência com percentuais do total geral."""
    percentage_table = pd.crosstab(df['employment_type'], df['company_size'], normalize='all') * 100
    display(HTML(percentage_table.round(2).to_html(index=False, border=0)))

generate_percentage_table(df)

"""## **Gráfico de Calor (Heatmap)**"""

def plot_heatmap(df):
    """Cria e plota o gráfico de calor (heatmap) baseado na tabela de frequências absolutas."""
    contingency = pd.crosstab(df['employment_type'], df['company_size'])
    plt.figure(figsize=(10, 6))
    sns.heatmap(contingency, annot=True, cmap='Blues', fmt='d', cbar_kws={'label': 'Frequência'})
    plt.title('Tabela de Contingência - Frequência entre Employment_type e Company_size')
    plt.ylabel('Employment Type')
    plt.xlabel('Company Size')
    plt.show()

plot_heatmap(df)

"""# **Tarefa 7**

**Análise:**
A análise das medidas descritivas para a variável salary_in_usd, estratificada pela variável experience_level, revela algumas tendências interessantes. Os dados mostram que os profissionais com níveis de experiência mais altos tendem a ter salários médios significativamente superiores. A mediana também confirma essa tendência, com as medianas aumentando à medida que o nível de experiência sobe. Além disso, a variabilidade dos salários, medida pelo desvio padrão, é mais alta em níveis de experiência avançada, indicando que os salários variam mais dentro desse grupo. A presença de valores discrepantes é observada, especialmente em níveis de experiência sêniores, onde alguns salários estão bem acima da maioria. O coeficiente de variação, que quantifica a variabilidade relativa, também indica maior dispersão entre os salários em níveis de experiência mais altos, sugerindo uma homogeneidade menor nesse grupo.

## **Medidas Descritivas para salary_in_usd estratificadas por experience_level**
"""

def calculate_salary_statistics(df):
    """Calcula e exibe as medidas descritivas para salary_in_usd estratificadas por experience_level."""
    medidas_descritivas = df.groupby('experience_level')['salary_in_usd'].agg(
        média='mean',
        mediana='median',
        mínimo='min',
        máximo='max',
        desvio_padrao='std',
        coeficiente_variacao=lambda x: (x.std() / x.mean() * 100),
        primeiro_quartil=lambda x: x.quantile(0.25),
        terceiro_quartil=lambda x: x.quantile(0.75)
    ).reset_index()

    # Arredondar os valores para duas casas decimais
    medidas_descritivas = medidas_descritivas.round(2)

    # Exibir a tabela de medidas descritivas
    display(HTML(medidas_descritivas.to_html(index=False, border=0)))

calculate_salary_statistics(df)

"""## **Boxplot**"""

def plot_salary_boxplot(df):
    """Cria o boxplot para salary_in_usd estratificado por experience_level."""
    plt.figure(figsize=(10, 6))
    sns.boxplot(x='experience_level', y='salary_in_usd', data=df, hue='experience_level', palette='Set3', dodge=True)
    plt.title('Boxplot de Salary in USD por Experience Level')
    plt.ylabel('Salary in USD')
    plt.xlabel('Experience Level')
    plt.grid(True)
    plt.legend(title='Experience Level', loc='upper right', bbox_to_anchor=(1.2, 1))  # Ajuste da legenda
    plt.show()

plot_salary_boxplot(df)

"""# **Tarefa 8**

**Análise:**
A análise das medidas descritivas para a variável salary_in_usd, estratificada por employment_type, revela diferenças significativas nas remunerações entre os diferentes tipos de contrato. O emprego em tempo integral apresenta a maior média salarial (149987.69 USD) e uma mediana correspondente (141525.0 USD), indicando que este tipo de emprego tende a oferecer os melhores salários. Em contraste, os freelancers têm a média salarial mais baixa (49220.86 USD) e uma mediana próxima (47777.5 USD), refletindo uma distribuição de salários que é mais afetada por variações e menos consistente. O desvio padrão é mais alto para os trabalhadores em contrato (91675.96 USD), sugerindo uma maior variabilidade nos salários, enquanto os trabalhadores em tempo integral apresentam uma menor dispersão. A presença de valores discrepantes é notável, especialmente para os freelancers e contratados, onde alguns casos estão bem acima do intervalo interquartil, indicando que, embora a maioria receba salários mais baixos, há exceções que elevam a média. O coeficiente de variação também sugere uma maior homogeneidade nas remunerações para empregos em tempo integral em comparação com os outros tipos de emprego.
"""

def plot_salary_statistics_by_employment(df):
    """Calcula e plota as medidas descritivas para a variável salary_in_usd estratificadas por Employment_type."""

    # Calculando as medidas descritivas estratificadas
    medidas_descritivas = df.groupby('employment_type')['salary_in_usd'].agg(
        média='mean',
        mediana='median',
        mínimo='min',
        máximo='max',
        desvio_padrao='std',
        coeficiente_variacao=lambda x: (x.std() / x.mean() * 100),
        primeiro_quartil=lambda x: x.quantile(0.25),
        terceiro_quartil=lambda x: x.quantile(0.75)
    ).reset_index()

    # Arredondando os valores
    medidas_descritivas = medidas_descritivas.round(2)

    # Exibir as medidas descritivas
    print("Medidas Descritivas para salary_in_usd estratificadas por Employment_type:")
    display(HTML(medidas_descritivas.to_html(index=False, border=0)))

    # Criando o boxplot estratificado
    plt.figure(figsize=(10, 6))
    sns.boxplot(x='employment_type', y='salary_in_usd', data=df, hue='employment_type', palette='Set3', dodge=False)
    plt.title('Boxplot de Salary in USD por Employment Type')
    plt.ylabel('Salary in USD')
    plt.xlabel('Employment Type')
    plt.grid(True)

    # Adicionando a legenda manualmente
    handles = [plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=color, markersize=10)
               for color in sns.color_palette('Set3', len(df['employment_type'].unique()))]
    plt.legend(handles, df['employment_type'].unique(), title='Employment Type', loc='upper right', bbox_to_anchor=(1.2, 1))

    plt.show()

# Chamando a função para gerar as medidas descritivas e o gráfico
plot_salary_statistics_by_employment(df)

"""## **Medidas descritivas para salary_in_usd estratificadas por employment_type**"""

def calculate_salary_statistics_by_employment(df):
    """Calcula e exibe as medidas descritivas para salary_in_usd estratificadas por employment_type."""
    medidas_descritivas = df.groupby('employment_type')['salary_in_usd'].agg(
        média='mean',
        mediana='median',
        mínimo='min',
        máximo='max',
        desvio_padrao='std',
        coeficiente_variacao=lambda x: (x.std() / x.mean() * 100),
        primeiro_quartil=lambda x: x.quantile(0.25),
        terceiro_quartil=lambda x: x.quantile(0.75)
    ).reset_index()

    # Arredondar os valores para duas casas decimais
    medidas_descritivas = medidas_descritivas.round(2)

    # Exibir as medidas descritivas
    display(HTML(medidas_descritivas.to_html(index=False, border=0)))

calculate_salary_statistics_by_employment(df)

"""## **Boxplot**"""

def plot_salary_boxplot_by_employment(df):
    """Cria o boxplot para salary_in_usd estratificado por employment_type."""
    plt.figure(figsize=(10, 6))
    sns.boxplot(x='employment_type', y='salary_in_usd', data=df, hue='employment_type', palette='Set3', dodge=False)
    plt.title('Boxplot de Salary in USD por Employment Type')
    plt.ylabel('Salary in USD')
    plt.xlabel('Employment Type')
    plt.grid(True)

    # Criando a legenda manualmente
    handles = [plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=color, markersize=10)
               for color in sns.color_palette('Set3', len(df['employment_type'].unique()))]
    plt.legend(handles, df['employment_type'].unique(), title='Employment Type', loc='upper right', bbox_to_anchor=(1.2, 1))

    plt.show()

plot_salary_boxplot_by_employment(df)

"""# **Tarefa 9**

**Discussão:**
Um gráfico de linhas seria ideal para representarmos a evolução dos salários ao longo do tempo caso houvesse dados de diferentes anos. Entretanto, para este conjunto de dados, poderíamos usar um gráfico de linhas para visualizar como os salários variam com base em um fator contínuo, como o nível de experiência. Abaixo segue um exemplo do Salário Médio por Nível de Experiência:
"""

def plot_line_graph_salary_by_experience(df):
    """Gráfico de linhas da média Salarial em Dólar por Nível de Experiência"""

    # Agrupar por experience_level e então calcular a média de salary_in_usd para cada nível de experiência
    salary_by_experience = df.groupby('experience_level')['salary_in_usd'].mean().reset_index()

    # Ordenar os valores por nível de experiência para deixar o gráfico mais limpo
    salary_by_experience = salary_by_experience.sort_values(by='salary_in_usd')

    # Plotting dos dados com o X = Nível de Experiência, Y = Salário em Dólar
    plt.figure(figsize=(10, 6))
    sns.lineplot(data=salary_by_experience, x='experience_level', y='salary_in_usd', marker='o')

    plt.title('Salário Médio por Nível de Experiência')
    plt.xlabel('Nível de Experiência')
    plt.ylabel('Salário Médio em USD')
    plt.grid(True)

    plt.tight_layout()
    plt.show()

plot_line_graph_salary_by_experience(df)

"""# **Tarefa 10**

Mapas de calor em tabelas são ferramentas eficazes para visualizar padrões e tendências em grandes conjuntos de dados. Eles facilitam a interpretação rápida ao destacar valores de interesse, como altos e baixos, através da atribuição de cores a diferentes intervalos de dados.

As principais utilidades dos Mapas de Calor são:



*   Identificação de Padrões: Permitem visualizar rapidamente concentrações de valores extremos ou mudanças de tendência.
*   Comparação Visual: Facilitam a comparação entre colunas ou linhas, evitando a análise de cada número individualmente.
*   Detecção de Outliers: Valores atípicos se tornam evidentes devido a suas cores distintas.
*   Auxílio na Tomada de Decisões: Destacam áreas problemáticas ou de sucesso, ajudando na priorização de ações.
"""

def plot_heatmap(df):
    """Plota tabela mapa de calor de salary_in_usd e remote_ratio"""
    #Como temos muitos Dados separamos primeiro somente uma parte deles para o mapa de calor
    #Selecionando as linha que contem somente trabalhadores "Data Science"
    # Selecionando as colunas numéricas que farão parte do mapa de calor
    filtered_df = df[df['job_title'].str.contains('Data Science', case=False)]
    df_numerical = filtered_df[['salary_in_usd', 'remote_ratio']]

    # Convertendo qualquer dado não numérico ou faltante para evitar erros
    df_numerical = df_numerical.apply(pd.to_numeric, errors='coerce').dropna()

    # Gerando o mapa de calor com as colunas selecionadas
    fig, axes = plt.subplots(1, 2, figsize=(8, 120))

    # Heatmap para salary_in_usd
    sns.heatmap(filtered_df[['salary_in_usd']], ax=axes[0], cmap='Greens', annot=True, cbar=False, linewidths=0.5, vmin=-1, vmax=290000, fmt='d')
    axes[0].set_title('Salary in USD')

    # Heatmap para remote_ratio
    sns.heatmap(filtered_df[['remote_ratio']],yticklabels=False, ax=axes[1], cmap='YlGn', annot=True, cbar=False, linewidths=0.5, vmin=-1, vmax=100, fmt='d')
    axes[1].set_title('Remote Ratio')

    # Definindo o título geral do mapa de Calor
    fig.suptitle('Salário e Proporção de Trabalho Remoto\n', fontsize=16)

    # Ajustando o layout para melhorar a aparência
    plt.tight_layout(rect=[0, 0, 1,0.98])
    plt.show()
plot_heatmap(df)